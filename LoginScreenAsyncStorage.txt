// screens/LoginScreen.tsx
import React, { useState } from "react";
import {
  View,
  TextInput,
  Button,
  Alert,
  StyleSheet,
  Text,
  TouchableOpacity,
} from "react-native";
import { NativeStackNavigationProp } from "@react-navigation/native-stack";
import { useNavigation } from "@react-navigation/native";
import useFetch from "./hooks/useFetch";
import user, { Boat } from "./types/UserType.types";
import useLocalStorage from "./hooks/AsyncStorage"; // import du hook
import { jwtDecode  } from "jwt-decode";
import { get } from "http";


type RootStackParamList = {
  Login: undefined;
  AccueilHome: {
    userName: string;
    boatList?: string[]; // ‚ùå ici TypeScript attend un array de string
  };
};


type LoginScreenNavigationProp = NativeStackNavigationProp<
  RootStackParamList,
  "Login"
>;

export default function LoginScreen() {
  const navigation = useNavigation<LoginScreenNavigationProp>();
const tokenStorage = useLocalStorage<string>("authToken");
/*Le <string> ici indique √† TypeScript le type de donn√©es que tu vas stocker.

Comme le token est une cha√Æne de caract√®res, on met string.

Si plus tard tu veux stocker un objet { token: string; username: string }, tu pourrais mettre <{ token: string; username: string }> */

  const [nom, setNom] = useState("");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [boatListe, setBoatList] = useState<Boat[]>([]);
  const { POST,GET } = useFetch();

  const handleLogin = async () => {
    console.log("üîê Bouton Connexion cliqu√©"); // debug

    if (!nom || !email || !password) {
      Alert.alert("Erreur", "Veuillez remplir tous les champs !");
      return;
    }

    const newUser: user = {
      username: nom,
      password: password,
    };

    try {
     console.log("üîê Tentative de connexion pour :", nom);
    // newUser est de type 'user', la r√©ponse contient { token: string }
const response = await POST<user, { token: string }>("/auth", newUser);

      console.log("‚úÖ R√©ponse du serveur :", response);

      // Stocker le token dans le localStorage
   if (response?.token) {
  tokenStorage.setItem(response.token); // utilise ton hook useLocalStorage<string>
  console.log("‚úÖ Token stock√© avec useLocalStorage :", response.token);
}



// dans ton handleLogin ou apr√®s r√©cup√©ration du token
const getedToken = await tokenStorage.getItem();

if (getedToken) {
  type TokenPayload = {
    username: string;
    isAdmin?: boolean;
    exp?: number;
  };

  const decoded: TokenPayload = jwtDecode <TokenPayload>(getedToken);
  console.log("üóùÔ∏è Token d√©cod√© :", decoded);
  if (decoded.isAdmin) {
    console.log("üëë L'utilisateur est un administrateur.");
  }else {
    console.log("üôÖ‚Äç‚ôÇÔ∏è L'utilisateur n'est pas un administrateur.");
  }

}
      Alert.alert("Succ√®s", "Connexion r√©ussie !");
  const fetchBoats = async () => {
      try {
        const listboats = await GET<Boat[]>('/boats');
        setBoatList(listboats || []);
      } catch (error) {
        console.error('Erreur lors du chargement des bateaux :', error);
      } 
    };
    fetchBoats();
      // Naviguer vers l'√©cran d'accueil avec le nom d'utilisateur boatsList: boatList.map(boat => boat.name) 
 // Par exemple dans ton √©cran pr√©c√©dent
 navigation.navigate('AccueilHome', { 
  userName: nom,
  boatList: boatListe, // doit correspondre exactement au type
});


    } catch (error) {
      console.error("‚ùå Erreur connexion :", error);
      Alert.alert("Erreur", "Impossible de se connecter");
    }
  };

  return (
    <View style={styles.container}>
      <TextInput
        placeholder="Nom"
        style={styles.input}
        value={nom}
        onChangeText={setNom}
      />
      <TextInput
        placeholder="Email"
        style={styles.input}
        value={email}
        onChangeText={setEmail}
      />
      <TextInput
        placeholder="Mot de passe"
        style={styles.input}
        value={password}
        onChangeText={setPassword}
        secureTextEntry
      />

      <Button title="Connexion" onPress={handleLogin} />

      <TouchableOpacity
        onPress={() => navigation.navigate("AccueilHome", { userName: nom })}
      >
        <Text style={styles.link}>Aller √† la page d'accueil</Text>
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, justifyContent: "center", padding: 20 },
  input: {
    borderWidth: 1,
    borderColor: "#ccc",
    borderRadius: 8,
    padding: 10,
    marginBottom: 12,
  },
  link: {
    color: "blue",
    marginTop: 20,
    textAlign: "center",
  },
});


/*

const handleLogin = async () => {
  if (!nom || !email || !password) {
    Alert.alert("Erreur", "Veuillez remplir tous les champs !");
    return;
  }

  const newUser: user = {
    username: nom,
    password: password,
  };

  try {
    console.log("üîê Tentative de connexion pour :", nom);

    const data = await POST<{ token?: string; error?: string }>("/auth", newUser);

    // ‚úÖ V√©rification s√©curis√©e sans response.ok
    if (!data || !data.token) {
      const message = data?.error || "Identifiants invalides ou token manquant";
      Alert.alert("Erreur", message);
      return;
    }

    await AsyncStorage.setItem("userToken", data.token);
    console.log("‚úÖ Token stock√© :", data.token);

    // üîç Utiliser la fonction utilitaire pour d√©coder
    const payload: TokenPayload | null = await getDecodedToken();
    console.log("üîì D√©codage du token effectu√©.");
    console.log("Payload re√ßu :", payload);

    if (payload) {
      console.log("üì¶ Payload du token :", payload);

      if (payload.isAdmin === true) {
        console.log("üëë L'utilisateur est un administrateur.");
      } else {
        console.log("üôÖ‚Äç‚ôÇÔ∏è L'utilisateur n'est pas un administrateur.");
      }
    }

    // üöÄ Navigation vers l'accueil
    console.log("‚û°Ô∏è Navigation vers AccueilHome avec nom :", nom);
    navigation.navigate("AccueilHome", { userName: nom });

    Alert.alert("Succ√®s", "Connexion r√©ussie !");
  } catch (error) {
    console.error("‚ùå Erreur :", error);
    Alert.alert("Erreur", "Impossible de se connecter");
  }
};
*/